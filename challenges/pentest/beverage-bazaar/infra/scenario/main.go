package main

import (
	"fmt"

	"github.com/ctfer-io/chall-manager/sdk"
	"github.com/mitchellh/mapstructure"
	appsv1 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/apps/v1"
	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/core/v1"
	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

const (
	ftp_port = 2100
	ssh_port = 22
)

type Additional struct {
	Image          string `json:"image"`
	ConnectionInfo string `json:"connection-info"`
	Flag           string `json:"flag"`
}

func main() {
	sdk.Run(func(req *sdk.Request, resp *sdk.Response, opts ...pulumi.ResourceOption) error {

		labels := pulumi.ToStringMap(map[string]string{
			"identity":  req.Config.Identity,
			"category":  "pentest",
			"challenge": "beverage-bazaar",
		})

		var additional Additional
		err := mapstructure.Decode(req.Config.Additional, &additional)
		if err != nil {
			return err
		}

		// load defaults value
		if additional.Image == "" {
			additional.Image = "localhost:5000/ctferio/beverage-bazaar:latest"
		}

		if additional.ConnectionInfo == "" {
			additional.ConnectionInfo = "localhost"
		}

		if additional.Flag == "" {
			additional.Flag = "Anonymous_FTP_Connection"
		}

		flag := pulumi.Sprintf("24HIUT{%s}", sdk.Variate(req.Config.Identity, additional.Flag))

		svcName := fmt.Sprintf("beverage-bazaar-svc-%s", req.Config.Identity)
		challenge_svc, err := corev1.NewService(req.Ctx, svcName, &corev1.ServiceArgs{
			Metadata: metav1.ObjectMetaArgs{
				Labels: labels,
				Name:   pulumi.String(svcName),
			},
			Spec: corev1.ServiceSpecArgs{
				Selector: labels,
				Type:     pulumi.String("NodePort"),
				Ports: corev1.ServicePortArray{
					corev1.ServicePortArgs{
						Name:       pulumi.String("ssh"),
						Port:       pulumi.Int(ssh_port),
						TargetPort: pulumi.Int(ssh_port),
					},
					corev1.ServicePortArgs{
						Name:       pulumi.String("ftp"),
						Port:       pulumi.Int(ftp_port),
						TargetPort: pulumi.Int(ftp_port),
					},
					corev1.ServicePortArgs{
						Name:       pulumi.String("ftpdata"),
						Port:       pulumi.Int(30000),
						TargetPort: pulumi.String("ftpdata"), // use the name because the containerPort must be the generated nodePort
					},
				},
			},
		}, opts...)
		if err != nil {
			return err
		}

		_, err = corev1.NewConfigMap(req.Ctx, "beverage-bazaar-cm", &corev1.ConfigMapArgs{
			Metadata: metav1.ObjectMetaArgs{
				Labels: labels,
				Name:   pulumi.String("beverage-bazaar-cm"),
			},
			Data: pulumi.StringMap{
				"vsftpd.conf": challenge_svc.Spec.ApplyT(func(spec *corev1.ServiceSpec) string {
					pftp_nport := spec.Ports[2].NodePort

					out := fmt.Sprintf(`listen=YES
listen_ipv6=NO
anonymous_enable=YES
local_enable=YES
write_enable=NO
dirmessage_enable=YES
use_localtime=YES
xferlog_enable=YES
connect_from_port_20=YES
ftpd_banner=Welcome to PopaCola fileserver.
secure_chroot_dir=/var/run/vsftpd/empty
pam_service_name=vsftpd
rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem
rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key
ssl_enable=NO
listen_port=%d
pasv_enable=YES
pasv_min_port=%d
pasv_max_port=%d
anon_root=/ftp`, ftp_port, pftp_nport, pftp_nport)
					return out
				}).(pulumi.StringOutput),
				"flag.txt": flag,
			},
		}, opts...)
		if err != nil {
			return err
		}

		_, err = appsv1.NewDeployment(req.Ctx, "beverage-bazaar-deploy", &appsv1.DeploymentArgs{
			Metadata: metav1.ObjectMetaArgs{
				Labels: labels,
			},
			Spec: appsv1.DeploymentSpecArgs{
				Selector: metav1.LabelSelectorArgs{
					MatchLabels: labels,
				},
				Template: corev1.PodTemplateSpecArgs{
					Metadata: metav1.ObjectMetaArgs{
						Labels: labels,
					},
					Spec: corev1.PodSpecArgs{
						Containers: corev1.ContainerArray{
							corev1.ContainerArgs{
								Name:  pulumi.String("challenge"),
								Image: pulumi.String(additional.Image),
								Ports: corev1.ContainerPortArray{
									corev1.ContainerPortArgs{
										Name: pulumi.String("ftpdata"),
										ContainerPort: challenge_svc.Spec.ApplyT(func(spec *corev1.ServiceSpec) int {
											return *spec.Ports[2].NodePort
										}).(pulumi.IntOutput),
									},
									corev1.ContainerPortArgs{
										ContainerPort: pulumi.Int(ftp_port),
									},
									corev1.ContainerPortArgs{
										ContainerPort: pulumi.Int(ssh_port),
									},
								},
								VolumeMounts: corev1.VolumeMountArray{
									corev1.VolumeMountArgs{
										MountPath: pulumi.String("/etc/vsftpd.conf"),
										Name:      pulumi.String("config"),
										SubPath:   pulumi.String("vsftpd.conf"),
									},
									corev1.VolumeMountArgs{
										MountPath: pulumi.String("/home/mdupuis/flag.txt"),
										Name:      pulumi.String("config"),
										SubPath:   pulumi.String("flag.txt"),
									},
								},
							},
						},
						Volumes: corev1.VolumeArray{
							corev1.VolumeArgs{
								Name: pulumi.String("config"),
								ConfigMap: corev1.ConfigMapVolumeSourceArgs{
									Name: pulumi.String("beverage-bazaar-cm"),
								},
							},
						},
					},
				},
			},
		}, opts...)
		if err != nil {
			return err
		}

		resp.ConnectionInfo = challenge_svc.Spec.ApplyT(func(spec *corev1.ServiceSpec) string {
			ftp_nport := spec.Ports[1].NodePort
			ssh_nport := spec.Ports[0].NodePort
			return fmt.Sprintf("FTP: %s %d \n SSH: %s %d", additional.ConnectionInfo, *ftp_nport, additional.ConnectionInfo, *ssh_nport)
		}).(pulumi.StringOutput)
		resp.Flag = flag
		return nil
	})
}
