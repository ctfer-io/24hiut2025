package main

import (
	"fmt"
	"net/url"
	"strings"

	"github.com/ctfer-io/chall-manager/sdk"
	"github.com/go-playground/form/v4"
	appsv1 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/apps/v1"
	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/core/v1"
	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

const (
	baseFlag = "Anonymous_FTP_Connection"
	ftpPort  = 2100
	sshPort  = 22
)

type Config struct {
	Hostname string `form:"hostname"`
	Registry string `form:"registry"`
	Image    string `form:"image"`

	ConnectionInfo string `form:"connectionInfo"`
}

func main() {
	sdk.Run(func(req *sdk.Request, resp *sdk.Response, opts ...pulumi.ResourceOption) error {
		conf, err := loadConfig(req.Config.Additional)
		if err != nil {
			return err
		}

		flag := pulumi.Sprintf("24HIUT{%s}", sdk.Variate(req.Config.Identity, baseFlag))

		labels := pulumi.StringMap{
			"chall-manager.ctfer.io/kind":      pulumi.String("custom"),
			"chall-manager.ctfer.io/identity":  pulumi.String(req.Config.Identity),
			"chall-manager.ctfer.io/category":  pulumi.String("pentest"),
			"chall-manager.ctfer.io/challenge": pulumi.String("beverage-bazaar"),
		}

		svcName := fmt.Sprintf("beverage-bazaar-svc-%s", req.Config.Identity)
		svc, err := corev1.NewService(req.Ctx, svcName, &corev1.ServiceArgs{
			Metadata: metav1.ObjectMetaArgs{
				Labels: labels,
				Name:   pulumi.String(svcName),
			},
			Spec: corev1.ServiceSpecArgs{
				Selector: labels,
				Type:     pulumi.String("NodePort"),
				Ports: corev1.ServicePortArray{
					corev1.ServicePortArgs{
						Name:       pulumi.String("ssh"),
						Port:       pulumi.Int(sshPort),
						TargetPort: pulumi.Int(sshPort),
					},
					corev1.ServicePortArgs{
						Name:       pulumi.String("ftp"),
						Port:       pulumi.Int(ftpPort),
						TargetPort: pulumi.Int(ftpPort),
					},
					corev1.ServicePortArgs{
						Name:       pulumi.String("ftpdata"),
						Port:       pulumi.Int(30000),
						TargetPort: pulumi.String("ftpdata"), // use the name because the containerPort must be the generated nodePort
					},
				},
			},
		}, opts...)
		if err != nil {
			return err
		}

		cm, err := corev1.NewConfigMap(req.Ctx, "beverage-bazaar-cm", &corev1.ConfigMapArgs{
			Metadata: metav1.ObjectMetaArgs{
				Labels: labels,
			},
			Data: pulumi.StringMap{
				"vsftpd.conf": svc.Spec.ApplyT(func(spec *corev1.ServiceSpec) string {
					pftp_nport := spec.Ports[2].NodePort

					out := fmt.Sprintf(`listen=YES
listen_ipv6=NO
anonymous_enable=YES
local_enable=YES
write_enable=NO
dirmessage_enable=YES
use_localtime=YES
xferlog_enable=YES
connect_from_port_20=YES
ftpd_banner=Welcome to PopaCola fileserver.
secure_chroot_dir=/var/run/vsftpd/empty
pam_service_name=vsftpd
rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem
rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key
ssl_enable=NO
listen_port=%[1]d
pasv_enable=YES
pasv_min_port=%[2]d
pasv_max_port=%[2]d
anon_root=/ftp`, ftpPort, pftp_nport)
					return out
				}).(pulumi.StringOutput),
				"flag.txt": flag,
			},
		}, opts...)
		if err != nil {
			return err
		}

		_, err = appsv1.NewDeployment(req.Ctx, "beverage-bazaar-deploy", &appsv1.DeploymentArgs{
			Metadata: metav1.ObjectMetaArgs{
				Labels: labels,
			},
			Spec: appsv1.DeploymentSpecArgs{
				Selector: metav1.LabelSelectorArgs{
					MatchLabels: labels,
				},
				Template: corev1.PodTemplateSpecArgs{
					Metadata: metav1.ObjectMetaArgs{
						Labels: labels,
					},
					Spec: corev1.PodSpecArgs{
						Containers: corev1.ContainerArray{
							corev1.ContainerArgs{
								Name: pulumi.String("challenge"),
								Image: pulumi.String(func() string {
									if conf.Registry != "" && !strings.HasSuffix(conf.Registry, "/") {
										conf.Registry += "/"
									}
									return conf.Registry + conf.Image
								}()),
								Ports: corev1.ContainerPortArray{
									corev1.ContainerPortArgs{
										Name: pulumi.String("ftpdata"),
										ContainerPort: svc.Spec.ApplyT(func(spec *corev1.ServiceSpec) int {
											if spec.Ports[2].NodePort == nil {
												return 0
											}
											return *spec.Ports[2].NodePort
										}).(pulumi.IntOutput),
									},
									corev1.ContainerPortArgs{
										ContainerPort: pulumi.Int(ftpPort),
									},
									corev1.ContainerPortArgs{
										ContainerPort: pulumi.Int(sshPort),
									},
								},
								VolumeMounts: corev1.VolumeMountArray{
									corev1.VolumeMountArgs{
										MountPath: pulumi.String("/etc/vsftpd.conf"),
										Name:      pulumi.String("config"),
										SubPath:   pulumi.String("vsftpd.conf"),
									},
									corev1.VolumeMountArgs{
										MountPath: pulumi.String("/home/mdupuis/flag.txt"),
										Name:      pulumi.String("config"),
										SubPath:   pulumi.String("flag.txt"),
									},
								},
							},
						},
						Volumes: corev1.VolumeArray{
							corev1.VolumeArgs{
								Name: pulumi.String("config"),
								ConfigMap: corev1.ConfigMapVolumeSourceArgs{
									Name: cm.Metadata.Name(),
								},
							},
						},
					},
				},
			},
		}, opts...)
		if err != nil {
			return err
		}

		resp.ConnectionInfo = svc.Spec.ApplyT(func(spec *corev1.ServiceSpec) string {
			var ftpNPort int
			if spec.Ports[1].NodePort != nil {
				ftpNPort = *spec.Ports[1].NodePort
			}
			var sshNPort int
			if spec.Ports[0].NodePort != nil {
				sshNPort = *spec.Ports[0].NodePort
			}
			return fmt.Sprintf("FTP: %[1]s %[2]d \n SSH: %[1]s %[3]d", conf.ConnectionInfo, ftpNPort, sshNPort)
		}).(pulumi.StringOutput)
		resp.Flag = flag
		return nil
	})
}

func loadConfig(additionals map[string]string) (*Config, error) {
	// Default conf
	conf := &Config{
		Hostname:       "24hiut25.ctfer.io",
		Image:          "pentest/beverage-bazaar:v0.1.0",
		Registry:       "", // keep empty
		ConnectionInfo: "challenges.24hiut25.ctfer.io",
	}

	// Override with additionals
	dec := form.NewDecoder()
	if err := dec.Decode(conf, toValues(additionals)); err != nil {
		return nil, err
	}
	return conf, nil
}

func toValues(additionals map[string]string) url.Values {
	vals := make(url.Values, len(additionals))
	for k, v := range additionals {
		vals[k] = []string{v}
	}
	return vals
}
